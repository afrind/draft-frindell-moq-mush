



Media Over QUIC                                                   afrind
Internet-Draft                                                      Meta
Intended status: Informational                              1 April 2024
Expires: 3 October 2024


                 Media Using Server-Push in HTTP (MUSH)
                     draft-frindell-moq-mush-latest

Abstract

   This draft defines how to use HTTP/3 to publish and receive Tracks as
   defined in MoQ Transport using [HTTP3].  The draft does not use
   WebTransport, and as such only servers can publish.  Tough Cookies.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://afrind.github.io/draft-frindell-moq-mush/draft-frindell-moq-
   mush.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-frindell-moq-mush/.

   Discussion of this document takes place on the Media Over QUIC
   Working Group mailing list (mailto:moq@ietf.org), which is archived
   at https://mailarchive.ietf.org/arch/browse/moq/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/moq/.

   Source for this draft and an issue tracker can be found at
   https://github.com/afrind/draft-frindell-moq-mush.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 3 October 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Pronunciation
   4.  Requesting Tracks
     4.1.  Encoding Track Names in URLs
     4.2.  Request Headers
       4.2.1.  Priority
       4.2.2.  Other-Priority
       4.2.3.  Authentication Headers
     4.3.  Track Info Request
     4.4.  Fetch Request
       4.4.1.  Object-Range
     4.5.  Subscribe Request
       4.5.1.  Live-Start
     4.6.  Don’t Subscribe Request
   5.  Response
     5.1.  Response Headers
       5.1.1.  Object-Range
       5.1.2.  Live-Head
       5.1.3.  Dead-Head
       5.1.4.  Delivery-Mode
       5.1.5.  Expires
     5.2.  Object Delivery
     5.3.  Object Response Headers
       5.3.1.  Priority
       5.3.2.  Cryority
       5.3.3.  Delivery-Mode
       5.3.4.  Group-ID
     5.4.  Datagram Format
     5.5.  Response Capsules
       5.5.1.  Group End
       5.5.2.  Pod
       5.5.3.  Object Dropped
       5.5.4.  Mic Dropped
       5.5.5.  Just Dropped
       5.5.6.  Reason Phrase
       5.5.7.  Done
     5.6.  Request Capsules
       5.6.1.  Unsubscribe
       5.6.2.  How Do I Unsubscribe
     5.7.  Trailers
   6.  Security Considerations
   7.  IANA Considerations
   8.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   HTTP/3 can totally send media.  This is one way to do it folks.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Pronunciation

   MUSH rhymes with PUSH.

4.  Requesting Tracks

   To get information about a track, a client sends a Track Info
   request.  To retrieve tracks, a client sends a Fetch or a Subscribe
   request, or schedules a meeting with the MoQ Chairs.

4.1.  Encoding Track Names in URLs

   A Full Track Name consists of two components, a track namespace and a
   track name.  These are encoded in URLs with the track_namesapce and
   track_name query parameters.  The :path and :authority pseudo headers
   are set via the Connection URL.  The parameters are URL encoded.

4.2.  Request Headers

   The following headers are valid in requests.

4.2.1.  Priority

   This header indicates the priority of this track relative to other
   tracks and HTTP requests.  See [Priorities].

4.2.2.  Other-Priority

   This header is the other priority header that the working group is
   still discussing, but lacks consensus.  TODO.  You can send both this
   and the Priority header, or neither, and it means something different
   to every implementation.  Good luck.

4.2.3.  Authentication Headers

   Authentication information is optionally passed by subscribers using
   the headers of their choice.

4.3.  Track Info Request

   Track Info is represented as an HTTP HEAD for the track.

   No additional headers are allowed.

4.4.  Fetch Request

   Fetch is represented as an HTTP GET for the track.  To fetch a single
   object, add the group_id and object_id query parameters to the URL.
   To fetch a range of objects in a Track, omit these query parameters.
   The following additional headers are allowed.

4.4.1.  Object-Range

   The Object-Range header is a sf-dictionary with four integer fields:
   start_group, start_object, end_group and end_object.  The header
   defines the range of objects to be returned.  If the Object-Range is
   omitted, the entire track is requested up to the end or the live-head
   at the time the request was received.  Negative values are supported,
   and the publisher should interpret this as a request to go back in
   time and turn the camera on sooner.

4.5.  Subscribe Request

   Subscribe is represented as an HTTP POST to the track URL.  A client
   can only have one active Subscribe request for a track at the same
   time.  The following additional headers are allowed.

4.5.1.  Live-Start

   Live-Start is an enumeration with one of the following values:

   Next Object:  The subscription begins with the next published object
      in the largest group seen by the publisher or relay, or the next
      object if none have been published yet.

   Next Group:  The subscription begins with the first object published
      in the next group with a group ID higher than largest, or the next
      group if none have been published yet.

   Next Next Next Prev Prev Next Group:  The subscription is supposed to
      start after the next commercial break, except the receiver went
      too far forward, then too far backward before dialing it in.

4.6.  Don’t Subscribe Request

   The subscriber sends this message when they don’t want to receive any
   track data, but feels like they need to say something to keep the
   connection from getting awkward.  It is represented as an OPTIONS
   request.

5.  Response

   If the Track Info, Fetch or Subscribe request is successful, the
   status code is 200.  If the response is an error, the publisher will
   send an appropriate 400 or 500 status code.  If the publisher is
   feeling ornery, it can send one or more 100-continue responses before
   sending a real response code, because that is totally a thing you can
   do in HTTP.

5.1.  Response Headers

5.1.1.  Object-Range

   Fetch responses for a range contain an Object-Range header indicating
   the start and end locations for the range.  This will be a subset of
   the requested range if the requested end is beyond the end of the
   track or current live head.

5.1.2.  Live-Head

   If the track is currently live and the Live Head is known, the Fetch
   or Subscribe response will contain the largest group and largest
   object within that group.  This header is an sf-dictionary with
   integer fields largest-group and largest-object.

5.1.3.  Dead-Head

   If the track is not currently live, the Fetch or Subscribe response
   contains this header including a lyric from a Grateful Dead song.

5.1.4.  Delivery-Mode

   This header is an enumeration of the following values:

   Track:  All objects will be delivered in a single Push stream.

   Group:  Objects in the same group will be delivered on a single Push
      stream.

   Object:  Each object will be delivered in its own Push stream

   Byte:  Each byte of each object will be delivered in its own Push
      stream

   Datagram:  Each object will be delivered as an HTTP datagram.

5.1.5.  Expires

   This optional header specifies a time in seconds after which the
   publisher will end a Subscribe request.  Subscribers SHOULD
   resubscribe before their subscription expires if they wish to
   continue receiving the track.  This header MUST NOT be present in a
   response to a Track Info or Fetch request.

   Note there’s already an Expires HTTP header with a different format
   and meaning, but we decided to redefine it here anyway, mostly to
   troll the HTTP chairs.

5.2.  Object Delivery

   Objects in the response to Fetch and Subscribe are delivered via HTTP
   Server Push or HTTP Datagrams according to the Delivery-Mode of the
   track.

   That’s right, we said SERVER PUSH.  You standardized it and we’re
   using it.

5.3.  Object Response Headers

   The HTTP Response on the Push stream MUST have :status = 200, and can
   carry the following headers:

5.3.1.  Priority

   Sets the priority of the push stream per [Priorities].

5.3.2.  Cryority

   This header is sent by the Chairs if someone brings up a priority
   discussion in the middle of discussing something else, derailing
   working group progress for 2-5 weeks.

5.3.3.  Delivery-Mode

   The delivery mode for this track.  This MUST match the Delivery-Mode
   specified in the Fetch or Subscribe response.  This mode determines
   the format of the remainder of the stream.

   When Delivery-Mode = Track, the remainder of the stream is zero or
   more of the following fields

   {
     groupID (i)
     objectID (i)
     length(i)
     payload(..)
   }

   When Delivery-Mode = Group, the remainder of the stream is zero or
   more of the following fields

   {
     objectID (i)
     length(i)
     payload(..)
   }

   When Delivery-Mode = Object, the remainder of the stream is

   {
     objectID (i)
     payload(..)
   }

   When Delivery-Mode = Byte, the remainder of the stream is

   {
     objectID (i)
     offset (i)
     payload(..)
   }

5.3.4.  Group-ID

   The Group-ID for all objects in the stream.  This MUST be present
   when Delivery-Mode is Group or Object.  This MUST NOT be present when
   Delivery-Mode is Track.

5.4.  Datagram Format

   When Delivery-Mode is Datagram, the format of the Datagram is

   {
     groupID (i)
     objectID (i)
     priority (i)
     payload(..)
   }

5.5.  Response Capsules

   The format of the response payload on the request stream for Fetch
   and Subscribe requests is the Capsule Protocol (interleaved with
   PUSH_PROMSIE frames).  The following Capsules are defined for the
   publisher.

5.5.1.  Group End

   The publisher sends Group End after it sends the last object in a
   group.  It has type 0xF01 and the following format

   {
     groupID (i)
     largestObjectID (i)
   }

5.5.2.  Pod

   The publisher sends a Pod capsule to add an extra layer of
   indirection, because frames and capsules just weren’t enough.  It has
   type 0xF02, and the contents are multiplexed metadata streams
   formatted using [QuicOnStreams].

5.5.3.  Object Dropped

   The publisher sends Object Dropped when it resets a Data stream
   carrying an Object, or skips sending an object due to buffering and/
   or expiry.  It has type 0xF03 and the following format

   {
     groupID (i)
     objectID (i)
   }

5.5.4.  Mic Dropped

   The publisher sent something so amazing nothing further needs to be
   sent.  The connection is closed immediately.  It has type 0xF03 and
   no fields.

5.5.5.  Just Dropped

   The publisher sends Just Dropped to inform the subscriber there’s
   something new and exciting they should subscribe to.  It has type
   0xF04 and the following format

   {
     connectURL (s)
     trackNamespace (s)
     trackName (s)
     hotness (i)
   }

5.5.6.  Reason Phrase

   The publisher sends a Reason Phrase capsule to give a really clear
   explanation of why something just happened.  Nothing good ever comes
   from it, but that didn’t stop us.  It has a 2048 octet minimum size.
   It has type 0xF05 and the following format

   {
     reallyGoodReasonPhrase(s)
   }

5.5.7.  Done

   The publisher sends Done when it is done sending Data for this Track,
   followed by gracefully closing the stream.  It has type 0xF06 and the
   following format

   {
     status (i)
     reasonPhrase (s)
     contentExits (f)
     [finalGroupSent (i)]
     [finalObjectSent (i)]
   }

   The following status codes are defined:

                       +======+====================+
                       | Code | Reason             |
                       +======+====================+
                       |  0x0 | Unsubscribed       |
                       +------+--------------------+
                       |  0x1 | Internal Error     |
                       +------+--------------------+
                       |  0x2 | Unauthorized       |
                       +------+--------------------+
                       |  0x3 | Track Ended        |
                       +------+--------------------+
                       |  0x4 | Subscription Ended |
                       +------+--------------------+
                       |  0x5 | Going Away         |
                       +------+--------------------+
                       |  0x6 | Expired            |
                       +------+--------------------+

                                  Table 1

5.6.  Request Capsules

   The following capsules are defined for the receiver.

5.6.1.  Unsubscribe

   The receiver sends Unsubscribe when it wants the publisher to stop
   sending data for this request after a certain group.  It has type
   0xF07 and the following format

   {
     endGroupID (i)
   }

   The publisher will stop publishing objects once it has sent the Group
   End for the group with endGroupID.  It will then send a Done capsule
   with status=Unsubscribed.

   To unsubscribe immediately, rather than after a specific group, the
   subscriber sends a STOP_SENDING frame on the request stream.

5.6.2.  How Do I Unsubscribe

   The receiver sends a How Do I Unsubscribe capsule if they didn’t read
   this specification, which explained not one, but two different ways
   to unsubscribe already.  The publisher ignores this capsule and
   continues publishing.  It has type 0xF08 and no fields.

5.7.  Trailers

   Clients MUST support trailers in HTTP responses, but relays WONT.  If
   a publisher tries sending a trailer section it will probably crash
   the relay or corrupt the cache.

6.  Security Considerations

   This protocol probably has a DoS vector in its control messages,
   because it seems like we keep forgetting how to prevent ourselves
   from getting DoS'd in control messages.

7.  IANA Considerations

   This document has no IANA actions.

8.  Normative References

   [HTTP3]    Bishop, M., Ed., "HTTP/3", RFC 9114, DOI 10.17487/RFC9114,
              June 2022, <https://www.rfc-editor.org/rfc/rfc9114>.

   [Priorities]
              Oku, K. and L. Pardue, "Extensible Prioritization Scheme
              for HTTP", RFC 9218, DOI 10.17487/RFC9218, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9218>.

   [QuicOnStreams]
              Oku, K. and L. Pardue, "QUIC on Streams", Work in
              Progress, Internet-Draft, draft-kazuho-quic-quic-on-
              streams-00, 16 February 2024,
              <https://datatracker.ietf.org/doc/html/draft-kazuho-quic-
              quic-on-streams-00>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   Lirpa Sloof assisted in the writing of this specification.

Author's Address

   afrind
   Meta
   Email: afrind@meta.com
